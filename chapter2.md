[原文链接](http://chimera.labs.oreilly.com/books/1234000000754/ch02.html)

#用unittest模块扩展功能性测试

现在我们的测试只是检查了有"It worked"的页面，我们改改测试让它检查一下我们想要看到的真正的主页上的东西。

是该告诉大家我们将要构建怎样的一个网页应用了：一个TO-DO网站！我们其实是跟着潮流的：几年前，所有的网页教程都是创建一个博客，然后是论坛和投票，如今都是TO-DO列表。

一个TO-DO列表确实是一个很好的例子。首先它简单到只有字符串列表，所以很容易运行一个“最小可用”的列表应用。但是他能够很好地拓展－不同的数据模型，增加截止时间，提醒功能，与他人分享，提升客户端UI。它没有理由只是一个TO－DO列表，它可以是任何形式的列表。重点在于这个应用让我能够展现网页编程所有关键的要素以及你怎样在其中应用TDD思想。

##使用功能性测试来划定最小可用应用的范围
有Selenium的测试打开一个真正的浏览器，这能够帮助我们从用户的角度来看应用的功能是怎样的，这是我们把这样的测试称为*功能性测试（以下称之为FT）*。

这意味着FT是应用的明确说明，它记录了*用户故事*，用户是如何和一个功能交互的以及应用是如何响应的。

> 术语: 功能性测试(FT) == 可接受测试 (Acceptance Test) == 端到端测试 (End-to-End Test)
> 我口中的功能性测试，一些人可能更愿意称为可接受测试或者端到端测试，不管叫什么，重点在于这些测试是从外部来看整个应用。另一个术语是，*黑盒测试*，因为测试并不知道内部系统是如何工作的。

FT应该是一个人可以读懂的故事，因此在测试代码中我们在其中加入了注释。在写一个新的FT时，我们先写注释来描述用户故事的要点。可阅读性可以让我们和非程序员们共同讨论应用的需求和功能。

TDD和敏捷开发方法经常被放在一起，敏捷开发中我们经常提到的是最小可用应用，我们能够构建的最简单的并且仍然可用的应用长什么样，我们现在就来构建它，这样我们就可以尽快进行测试。

一个最小可用的TO－DO列表应用仅需要用户输入一些待办项目，并在下一次访问时能够记住它们。

打开*functional_tests.py*，写一个这样的故事：

functional_tests.py

	# Edith听说了一个很新潮的在线待办列表应用，她打开主页。
	browser.get('http://localhost:8000')

	# 她发现页面标题提到了to-do列表
	assert 'To-Do' in browser.title

	# 她直接输入了一个待办项目

	# 她在文本框中输入了"Buy peacock feathers"（Edith喜欢做飞鱼饵）

	# 当她敲击回车，页面更新了，现在页面列出了'1: Buy peacock feathers'

	# 页面上仍然有一个文本框，她接着输入“Use peacock feathers to make a fly”(Edith十分有条理)

	# 页面再次更新，在她的列表中，她看到两条记录

	# Edith想知道网站是否能够记住她的列表， 她看到网站为她生成了一个
	# 特有的URL地址并有一些解释性文字
	# 她访问那个URL － 她的列表仍然出现了

	# 她很满意，然后回去睡觉了

	browser.quit()

> **有关注释**
> 我刚开始在Resolver工作时，我曾经为代码写很多清晰漂亮的注释，我的同事告诉我：“Harry, 对于注释我们有一个词，我称它们为谎言”。我震惊了！在学校里学习的时候不是说注释是最佳实践吗？
> 他们可能说的夸张了，在某些情境下注释是绝对必要的。但是写注释来重述代码做的事情就没有意义，比如：
	
	# increment wibble by 1
	wibble += 1
> 它不仅没有意义，还很有问题，想想之后你更新了代码但是忘了修改注释，这会变得让人费解。最佳的方式是书写可读性强的代码，使用好的变量名称和方法名称，很好的组织它们这样你就不需要注释来解释你的代码在做什么。仅仅写一些来解释为什么这么做。
> 还有其他注释很有用的地方，Django在文档中会产生很多注释告诉我们怎么使用它的API。当然啦，我们使用注释来解释FT中的用户故事，这样强迫我们在测试中写一个一致的故事，也确保我们经常从用户的角度进行测试。
> 在这个领域还有很多有意思的话题，比如行为驱动开发(*Behavior Driven Development*)(参看[附录E](http://chimera.labs.oreilly.com/books/1234000000754/ape.html)), 测试DSL(*Domain Specific Language*)。这些已经超出了本书的范畴。

你可能已经注意到了，除了写注释，我也更新了**assert**语句，现在检查“To－Do”而不是"Django"，这意味着，我们预计这是一个会失败的测试，我们先运行一下：

首先，启动服务器：

	$ python3 manage.py runserver

其次在另一个shell中，运行测试：

	$ python3 functional_tests.py
	Traceback (most recent call last):
	  File "functional_tests.py", line 10, in <module>
	    assert 'To-Do' in browser.title
	AssertionError

这就是我们叫做的*预期的失败*，尽管和通过测试来比不那么好，但也确实是个好消息，至少它有一个正确的理由失败了，我们确信已经把测试写对了！